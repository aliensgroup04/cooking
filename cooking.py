# -*- coding: utf-8 -*-
"""cooking.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EZKm1yMTM1n8IhHb5SaE6iJwGisqZORi
"""
import streamlit as st
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import PydanticOutputParser
from pydantic import BaseModel, Field, ValidationError
import json

# Define Recipe Schema
class Recipe(BaseModel):
    ingredients: list = Field(description="List of ingredients for preparing the dish")
    process: list = Field(description="Steps to follow for preparing the dish")

# Output parser
output_parser = PydanticOutputParser(pydantic_object=Recipe)
model = ChatGoogleGenerativeAI(model="gemini-1.5-pro", google_api_key="AIzaSyBMCc42a-cWcpnG1TfCC830kbHG20dAqpo")

# Prompt Template
prompt_template = ChatPromptTemplate(
    messages=[
        (
            "system",
            """You are a helpful AI Chef Assistant.
            Given a dish name by the user, you provide the process of preparation step by step along with ingredients.
            Output Format Instructions:
            {output_format_instructions}""",
        ),
        ("human", "Give me the recipe and step-by-step instructions for cooking {dish_name}."),
    ],
    partial_variables={
        "output_format_instructions": output_parser.get_format_instructions()
    },
)

# Chain definition
chain = prompt_template | model | output_parser

# Streamlit UI
st.title("Chef Assistant üçΩÔ∏è")
user_input = st.text_input("Enter your dish name", placeholder="E.g., Pasta, Biryani")

if st.button("Get Recipe"):
    if user_input:
        with st.spinner("Fetching recipe...‚è≥"):
            input_data = {"dish_name": user_input}

            try:
                recipe = None  # To hold the final parsed recipe

                for chunk in chain.stream(input_data):
                    if isinstance(chunk, Recipe):  # Directly check if it's a Recipe object
                        recipe = chunk

                if recipe:
                    st.subheader("Ingredients:")
                    for ingredient in recipe.ingredients:
                        st.write(f"- {ingredient}")

                    st.subheader("Preparation Steps:")
                    for step in recipe.process:
                        st.write(f"{step}")
                else:
                    st.error("Failed to retrieve recipe. Please try again.")

            except ValidationError as e:
                st.error("Error parsing the response. Try again!")
                st.write(str(e))  # Display error details for debugging
    else:
        st.warning("Please enter a dish name!")
